package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"sync/atomic"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output    = flag.String("output", "./filter.go", "output file name; default srcDir/filter.go")
)

var template = `
func %v(v %v) bson.E {
	return bson.E{Key: "%v", Value: v}
}
`

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func checkField(name string) (string, bool) {
	if len(name) == 0 {
		return name, false
	}
	if name[0] >= 'A' && name[0] <= 'Z' {
		return "f" + name, true
	}
	return "", false
}

func parseTag(tagName string) (string, bool) {
	if len(tagName) < 2 {
		return "", false
	}
	// 去掉 ``
	tagName = tagName[1 : len(tagName)-1]
	var tag reflect.StructTag = reflect.StructTag(tagName)

	tg, ok := tag.Lookup("bson")
	if !ok {
		return "", true
	}
	var sp = strings.Split(tg, ",")
	if len(sp) < 1 {
		return "", true
	}
	for _, v := range sp {
		if v == "omitempty" {
			return "", false
		}
	}
	var name = sp[0]
	if name == "-" {
		return "", false
	}
	return name, true
}

// 输出缓存
var outBuffer = bytes.NewBuffer(nil)

func filterFunction(typ string, field *ast.Field) (add bool) {
	if len(field.Names) == 0 {
		return
	}
	var fieldName = field.Names[0].Name
	_, ok := checkField(fieldName)
	if !ok {
		return
	}

	paramType, ok := findFieldType(field.Type)
	if !ok {
		return
	}

	log.Printf("Type: %v paramType: %v", typ, paramType)

	var tg string
	if field.Tag != nil {
		// 尝试解析tag
		tg, ok = parseTag(field.Tag.Value)
		if !ok {
			return
		}
	}
	if tg == "" {
		// mongo的默认key
		tg = strings.ToLower(fieldName)
	}

	outBuffer.WriteString(
		fmt.Sprintf(
			template, typ+fieldName, paramType, tg,
		))
	return true
}

var genPath []string

func main() {

	log.SetFlags(0)
	log.SetPrefix("bson_filter: ")
	flag.Parse()
	genPath = flag.Args()
	if len(genPath) == 0 {
		genPath = append(genPath, ".")
	}
	filter()
}

func findFieldType(expr ast.Expr) (tpName string, tpValid bool) {
	switch typ := expr.(type) {
	case *ast.StarExpr:
		// 指针类型
		var val, ok = findFieldType(typ.X)
		if !ok {
			return
		}
		return "*" + val, true
	case *ast.ArrayType:
		// 切片类型
		var ele, ok = findFieldType(typ.Elt)
		if !ok {
			return
		}
		return "[]" + ele, true
	case *ast.MapType:
		// 字典类型
		var key, val string
		var ok bool
		key, ok = findFieldType(typ.Key)
		if !ok {
			return
		}
		val, ok = findFieldType(typ.Value)
		if !ok {
			return
		}
		return "map[" + key + "]" + val, true
	case *ast.Ident:
		// 通用类型(bool,float,int... etc)
		return typ.Name, true
	case *ast.IndexExpr:
		// 单个泛型参数的泛型类型
		var main, valid = findFieldType(typ.X)
		if !valid {
			return
		}
		var param, pv = findFieldType(typ.Index)
		if !pv {
			return
		}
		return main + "[" + param + "]", true
	case *ast.IndexListExpr:
		// 多个泛型参数的泛型类型
		var main, valid = findFieldType(typ.X)
		if !valid {
			return
		}
		var params []string
		for _, x := range typ.Indices {
			p, v := findFieldType(x)
			if !v {
				return
			}
			params = append(params, p)
		}
		if len(params) == 0 {
			return
		}
		return main + "[" + strings.Join(params, ",") + "]", true
	case *ast.SelectorExpr:
		var pkgName, pv = findFieldType(typ.X)
		if !pv {
			return
		}
		var pt, tv = findFieldType(typ.Sel)
		if !tv {
			return
		}
		return pkgName + "." + pt, true
	default:
		return
	}
}

func filter() {
	if len(*typeNames) == 0 {
		os.Exit(2)
	}

	var dir string
	if len(genPath) == 1 && isDirectory(genPath[0]) {
		dir = genPath[0]
	} else {
		dir = filepath.Dir(genPath[0])
	}

	var cfg = &packages.Config{
		Mode:  packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests: false,
	}

	var types = strings.Split(*typeNames, ",")

	var allTypes = make(map[string]struct{}, len(types))
	for _, typ := range types {
		allTypes[typ] = struct{}{}
	}

	loadPkg, err := packages.Load(cfg, dir)

	if err != nil || len(loadPkg) == 0 {
		log.Fatal(err)
	}

	outBuffer.WriteString(fmt.Sprintf("// Code generated by \"filter %s\"; DO NOT EDIT.\n", *typeNames))

	var total uint64

	var pkg = loadPkg[0]
	log.Printf("package name:%v", pkg.Name)
	outBuffer.WriteString(fmt.Sprintf("package %v", pkg.Name))
	outBuffer.WriteByte('\n')
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			var ts, ok = n.(*ast.TypeSpec)
			if !ok {
				return true
			}
			if _, ok := allTypes[ts.Name.Name]; !ok {
				return true
			}
			delete(allTypes, ts.Name.Name)
			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				return true
			}
			for _, field := range st.Fields.List {
				if filterFunction(ts.Name.Name, field) {
					atomic.AddUint64(&total, 1)
				}
			}
			return len(allTypes) != 0
		})
	}

	if atomic.LoadUint64(&total) == 0 {
		log.Printf("not found valid filter function")
		return
	}

	// format
	dst, err := format.Source(outBuffer.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	// import
	bs, err := imports.Process(*output, dst, nil)
	if err != nil {
		log.Fatal(err)
	}
	// write
	err = os.WriteFile(*output, bs, fs.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
}
