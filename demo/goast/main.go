package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"unsafe"

	"golang.org/x/tools/go/packages"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
	output    = flag.String("output", "./filter.go", "output file name; default srcdir/filter.go")
)

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func toBytes(s string) []byte {
	type bsStruct struct {
		s string
		i int64
	}
	return *(*[]byte)(unsafe.Pointer(&bsStruct{s: s, i: int64(len(s))}))
}

func toString(bs []byte) string {
	return *(*string)(unsafe.Pointer(&bs))
}

func transfer[Dst any](src any) Dst { return src.(Dst) }

var ident = transfer[*ast.Ident]

func checkField(name string) (string, bool) {
	if len(name) == 0 {
		return name, false
	}
	if name[0] >= 'A' && name[0] <= 'Z' {
		var bs = []byte(name)
		bs[0] += byte('a' - 'A')
		return toString(bs), true
	}
	return "", false
}

func parseTag(tagName string) (string, bool) {
	if len(tagName) < 2 {
		return "", false
	}
	tagName = tagName[1 : len(tagName)-1]
	var tag reflect.StructTag = reflect.StructTag(tagName)

	tg, ok := tag.Lookup("bson")
	if !ok {
		return "", true
	}
	var sp = strings.Split(tg, ",")
	if len(sp) < 1 {
		return "", true
	}
	var name = sp[0]
	if name == "-" {
		return "", false
	}
	return name, true
}

var outBuffer = bytes.NewBuffer(nil)

func showSetFunction(typ string, field *ast.Field) {
	if len(field.Names) == 0 {
		return
	}
	var fieldName = field.Names[0].Name
	paramName, ok := checkField(fieldName)
	if !ok {
		return
	}
	ptr, ok := field.Type.(*ast.StarExpr)

	var template = `
func %v%v(%v %v%v) bson.E {
	return bson.E{Key: "%v", Value: %v}
}
`
	var pre string
	var name string
	if ok {
		pre = "*"
		name = ident(ptr.X).Name
	} else {
		name = ident(field.Type).Name
	}
	var tg string
	if field.Tag != nil {
		tg, ok = parseTag(field.Tag.Value)
		if !ok {
			return
		}
	}
	if tg == "" {
		tg = strings.ToLower(fieldName)
	}

	outBuffer.WriteString(fmt.Sprintf(template, typ, fieldName, paramName, pre, name, tg, paramName))
}

func main() {

	log.SetFlags(0)
	log.SetPrefix("goast: ")
	flag.Parse()
	if len(*typeNames) == 0 {
		os.Exit(2)
	}
	args := flag.Args()
	if len(args) == 0 {
		args = append(args, ".")
	}
	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	var cfg = &packages.Config{
		Mode:  packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests: false,
	}

	var types = strings.Split(*typeNames, ",")

	var allTypes = make(map[string]struct{}, len(types))
	for _, typ := range types {
		allTypes[typ] = struct{}{}
	}

	pkgs, err := packages.Load(cfg, dir)

	if err != nil || len(pkgs) == 0 {
		log.Fatal(err)
	}

	outBuffer.WriteString(fmt.Sprintf("// Code generated by \"filter %s\"; DO NOT EDIT.\n", *typeNames))

	var pkg = pkgs[0]
	log.Printf("package name:%v", pkg.Name)
	outBuffer.WriteString(fmt.Sprintf("package %v", pkg.Name))
	outBuffer.WriteByte('\n')
	outBuffer.WriteString(`import "go.mongodb.org/mongo-driver/bson"`)
	outBuffer.WriteByte('\n')
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(n ast.Node) bool {
			var ts, ok = n.(*ast.TypeSpec)
			if !ok {
				return true
			}
			if _, ok := allTypes[ts.Name.Name]; !ok {
				return true
			}
			delete(allTypes, ts.Name.Name)
			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				return true
			}
			for _, field := range st.Fields.List {
				showSetFunction(ts.Name.Name, field)
			}
			return len(allTypes) != 0
		})
	}

	dst, err := format.Source(outBuffer.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile(*output, dst, fs.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
}
